
/*=====================
★★★클래스 고급★★★
======================*/

// 상속(Inheritance)

// ※ super

// static 으로 선언되지 않은 메소드에서 사용되며, 현재 클래스가 상속받은 상위 클래스의
// 객체를 가리킨다. 
// super 는 상위 클래스의 생성자를 호출하거나, 상위 클래스의 멤버 변수 또는 메소드를 
// 호출할 때 사용할 수 있다.


// 하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
// 하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다.


// ※생성자와 클래스 상속간의 관계

// 하위 클래스는 상위 클래스의 멤버를 상속받지만, 생성자는 상속 대상에서 제외된다.
// 그리고 하위 클래스의 생성자가 호출될 때 자동으로 상위 클래스의 생성자를 호출하게 된다.
// 이 때, 상위 클래스의 생성자는 인수가 없는 생성자(default 생성자 형태)가 호출된다.

// 상위 클래스 및 하위 클래스(즉, 상속 관계에 있는 클래스)를 설계하는 과정에서
// 상위 클래스의 생성자를 정의하지(작성하지) 않거나
// 인수가 없는 생성자만을 정의한(작성한) 경우 명시적으로 하위 클래스에서 상위 클래스의 
// 생성자를 호출하지 않아도 아무런 문제가 발생하지 않지만
// 상위 클래스에 인자이 있는 생성자만 존재하는 경우에는 주의해야 한다.

// 예를 들어... 다음에서...

//생성자 설정을 잘못하면 시작도 못해보고 망할 수 있다.

/*
	class A_clss
	{
		A_class()
		{
			
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super();
		}
	}
*/
//하위 클래스인 B_class의 생성자에서 명시적으로 A_class의 생성자를 호출하지 않으면
//자동으로 인자가 없는 생성자를 호출한다.
//하지만, A_class에는 인자가 있는 생성자만 존재하고 인자가 없는 생성자는 존재하지 않기 때문에
//에러가 발생한다. 따라서 B_class 생성자의 선두에 다음처럼 명시적으로 상위 클래스의
//생성자 호출 구문을 작성해야 한다.
/*
	class A_class
	{
		A_class(int n)
		{
			
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super(10);   //int n = 10처럼 명시적으로 보여주어야 한다.
			...
			...
		}
	}
*/

/*
※ 상속 시 주의할 사항

	상위 클래스에서 선언된 멤버 변수의 이름과
	하위 클래스에서 선언된 멤버 변수의 이름이 같으면 상위 클래스의 멤버 변수는 무시된다.
	이 때, 상위 클래스의 멤버 변수를 사용하기 위해서는
	super 키워드를 이용한다.

	동일한 이름의 멤버 변수나 동일한 이름의 메소드가 한 클래스 안에 선언되거나
	정의 되는 경우 기본적으로 에러가 발생한다.
	단, 메소드의 경우에는 매개변수의 갯수나 타입이 다른 경우 에러가 발생하지 않고
	이들을 서로 다른 메소드로 취급하게 된다.
*/

// 삼국지전편				super.삼국지전편
//(내가 원래 갖고 있던 것)	(부모님으로부터 물려받은 것)

public class Test114
{
	public static void main(String[] args)
	{
		
	}
}