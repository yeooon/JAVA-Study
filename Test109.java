/*=======================================
★★★정렬(Sort) 알고리즘★★
========================================*/

/*
○ 정렬
	: 데이터를 특정한 규칙(기준)에 맞게 순서대로 나열(오름차순, 내림차순)

○ 정렬의 목적
	: 데이터 처리 과정의 편의성이나 가독성을 높이기 위함
	→ 보기 좋게... 검색하기 위함

○ 정렬의 종류
	: 선택 정렬, 버블 정렬, 삽입 정렬, 힙 정렬, 퀵 정렬, 쉘 정렬, ....
	정렬은 리소스 소모가 심하다

*/

// 선택 정렬(Selection Sort)

// 실행 예)
// Source Data : 52 42 12 62 60
// Sorted Data : 12 42 52 60 62
// 계속하려면 아무 키나 누르세요...

public class Test109
{
	public static void main(String[] args)
	{
		int a[] = {52, 42, 12, 62, 60};

/*
System.out.print("Source Data : ");

		for (int i=0;i<a.length;i++)
		{
			System.out.printf("%3d",a[i]);
		}
System.out.println();
*/
		
		//향상된 for문(foreach 구문)
		
		for (int n : a)			//for (데이터 타입 이름 붙이기 : 자료구조(a) )
		{
			System.out.print(n + " ");
		}
		System.out.println();

		//int save; //큰 수 임시 저장

		//Selection Sort
System.out.print("Sorted Data : ");		//오름차순, 내림차순 정렬

		for (int i=0;i<a.length-1;i++) // → 비교기준데이터 0 1 2 3
		{
			for (int j=i+1;j<a.length;j++)	// → 비교대상데이터 0 1 2 3(1234 234 34 4)//이중 for문은 비교를 위해 존재
			{
				if(a[i]>a[j])		//여기서부터 배열 공식같은 건가
				{
					int save = a[j];		//임시 저장 변수에 큰 수를 저장하고
					a[j]=a[i];				//바꾼다
					a[i]=save;				//작은 수를 저장해나가면서 바꾼다

					/*
					a[i]= a[i]^a[j];
					a[j]= a[j]^a[i];
					a[i]= a[i]^a[j];
					*/
				}							// i번째 배열요소가 기준이 되는 j번째 배열요소보다 작은 경우 save를 통해 배열의 자리를 서로 바꾼다. 
			}
		}
		for (int i=0;i<a.length;i++)
		{
			System.out.printf("%3d",a[i]);
		}
		System.out.println();
	}
}
/*
52, 42, 12, 62, 60
==  --
12, 52, 42, 62, 60
==      --
12, 52, 42, 62, 60
==          --
12, 52, 42, 62, 60
==              --
----------------------- 1회전
12, 42, 52, 62, 60
    ==  --
12, 42, 52, 62, 60
    ==      --
12, 42, 52, 62, 60
    ==          --
----------------------- 2회전
12, 42, 52, 62, 60
        ==  --
12, 42, 52, 62, 60
        ==      --
----------------------- 3회전
12, 42, 52, 60, 62
            ==  --
----------------------- 4회전
*/